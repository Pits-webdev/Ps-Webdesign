<div class="fixed top-0 left-0 w-full h-full -z-10 pointer-events-none">
   <canvas id="three-canvas" class="w-full h-full block bg-transparent"
   ></canvas>
</div>

<script>
   import { gsap } from "gsap";
   import { ScrollTrigger } from "gsap/ScrollTrigger";
   import * as THREE from "three";
   import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
   import { debug } from "../../lib/debug";
   import { fragmentShader } from "../../shaders/fragment";
   import { vertexShader } from "../../shaders//vertex";

   import { getCssColor } from "../../utils/getCssColor";

   gsap.registerPlugin(ScrollTrigger);

   const threeCanvas = document.getElementById(
      "three-canvas",
   ) as HTMLCanvasElement;

   // browser sizes
   const sizes = {
      width: window.innerWidth,
      height: window.innerHeight,
   };

   //scene
   const scene = new THREE.Scene();

   //camera
   const camera = new THREE.PerspectiveCamera(
      75,
      sizes.width / sizes.height,
      0.1,
      1000,
   );

   camera.position.z = 8;
   camera.position.y = 1;

   //renderer
   const renderer = new THREE.WebGLRenderer({
      antialias: true, // Antialias an für schönere Partikel
      canvas: threeCanvas,
      alpha: true,
   });

   renderer.setSize(sizes.width, sizes.height);
   renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
   renderer.setAnimationLoop(animate);

   // 2. CONTROLS INITIALISIEREN
   const controls = new OrbitControls(camera, threeCanvas);
   controls.enableDamping = true; // Weiches Bremsen der Kamera
   controls.dampingFactor = 0.05;

   /* Particle */
   //12*12*12 für box
   const particleCount = 1728;

   const positionPlane = [];
   const positionBox = [];
   const positionSphere = []; // NEU
   const randoms = [];

   // Configs
   const gridCols = Math.ceil(Math.sqrt(particleCount));
   const gridRows = Math.ceil(particleCount / gridCols);
   const planeSize = 7.0;

   const pointsPerSide = Math.ceil(particleCount ** (1 / 3));
   const boxSize = 4.0;

   const sphereRadius = 2.5; // NEU: Radius der Kugel

   for (let i = 0; i < particleCount; i++) {
      // --- A: PLANE (2D Gitter) ---
      const px = i % gridCols;
      const py = Math.floor(i / gridCols);
      const u = px / (gridCols - 1);
      const v = py / (gridRows - 1);
      positionPlane.push((u - 0.5) * planeSize, (v - 0.5) * planeSize, 0);

      // --- B: BOX (3D Gitter) ---
      const bxIndex = i % pointsPerSide;
      const byIndex = Math.floor(i / pointsPerSide) % pointsPerSide;
      const bzIndex = Math.floor(i / (pointsPerSide * pointsPerSide));
      const bu = bxIndex / (pointsPerSide - 1);
      const bv = byIndex / (pointsPerSide - 1);
      const bw = bzIndex / (pointsPerSide - 1);
      positionBox.push(
         (bu - 0.5) * boxSize,
         (bv - 0.5) * boxSize,
         (bw - 0.5) * boxSize,
      );

      // --- C: SPHERE (Fibonacci Spirale) - NEU ---
      // Das verteilt Punkte perfekt gleichmäßig auf einer Kugel
      const phi = Math.acos(-1 + (2 * i) / particleCount);
      const theta = Math.sqrt(particleCount * Math.PI) * phi;

      const sx = sphereRadius * Math.cos(theta) * Math.sin(phi);
      const sy = sphereRadius * Math.sin(theta) * Math.sin(phi);
      const sz = sphereRadius * Math.cos(phi);

      positionSphere.push(sx, sy, sz);

      randoms.push(Math.random());
   }

   /* Geometries */
   const geometry = new THREE.BufferGeometry();
   geometry.setAttribute(
      "position",
      new THREE.Float32BufferAttribute(positionPlane, 3),
   );

   geometry.setAttribute(
      "aBoxPosition",
      new THREE.Float32BufferAttribute(positionBox, 3),
   );

   geometry.setAttribute(
      "aSpherePosition",
      new THREE.Float32BufferAttribute(positionSphere, 3),
   );

   geometry.setAttribute(
      "aRandom",
      new THREE.Float32BufferAttribute(randoms, 1),
   );

   // Uniforms
   const uniforms = {
      uTime: { value: 0 },
      uResolution: {
         value: new THREE.Vector2(window.innerWidth, window.innerHeight),
      },
      uProgress: { value: 0 },
      uBoxShiftX: { value: 0.0 },
      uBoxScale: { value: 1.0 },
      uPlaneScaleX: { value: 3.0 },

      // Farben
      uColorBottom: { value: new THREE.Color(getCssColor("--bottomColor")) },
      uColorTop: { value: new THREE.Color(getCssColor("--topColor")) },

      // --- NEU: PARAMETER FÜR GUI ---

      //Plane
      uFrequency: { value: 6.0 }, // War uPlaneFreq
      uAmplitude: { value: 0.1 }, // War uPlaneAmp
      uSpeed: { value: 4.0 }, // War uPlaneSpeed
      uRotation: { value: 89 * (Math.PI / 180) }, // JS rechnet das automatisch in Bogenmaß um
   };

   //material
   const material = new THREE.ShaderMaterial({
      vertexShader: vertexShader,
      fragmentShader: fragmentShader,
      uniforms: uniforms,
      side: THREE.DoubleSide,
      transparent: true,
      depthWrite: false, // Wichtig für Partikel, damit sie sich nicht gegenseitig verdecken
      blending: THREE.AdditiveBlending, // Lässt sie leuchten
   });

   const particles = new THREE.Points(geometry, material);

   scene.add(particles);

   /* ****** lil Gui ***** */
   debug(material);

   const clock = new THREE.Clock();

   //animate
   function animate() {
      //material.uniforms.uTime.value = clock.getElapsedTime();
      const time = clock.getElapsedTime();

      // NEU: Loop von 0 bis 3
      // time * 0.5 bestimmt die Geschwindigkeit.
      // % 3.0 sorgt dafür, dass es bei 3.0 wieder auf 0 springt.
      //const progress = (time * 0.5) % 3.0;

      material.uniforms.uTime.value = time;
      //material.uniforms.uProgress.value = progress;

      // 3. CONTROLS UPDATE (Wichtig für Damping!)
      controls.update();

      renderer.render(scene, camera);
   }

   //resize
   window.addEventListener("resize", () => {
      sizes.width = window.innerWidth;
      sizes.height = window.innerHeight;

      camera.aspect = sizes.width / sizes.height;
      camera.updateProjectionMatrix();

      renderer.setSize(sizes.width, sizes.height);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
   });

   //Three js end

   //  *--- gsap ---*
   const sections = [
      { id: "hero", value: 0.0 },
      { id: "about", value: 1.0 },
      { id: "services", value: 2.0 },
   ];

   sections.forEach((section) => {
      // Für jede Section erstellen wir einen Trigger
      ScrollTrigger.create({
         trigger: `#${section.id}`, // z.B. "#about"

         // Wann soll der Wechsel passieren?
         // "top 60%" bedeutet: Wenn die Oberkante der Section
         // bei 60% der Bildschirmhöhe (etwas unter der Mitte) ankommt.
         start: "top 60%",
         end: "bottom 60%",

         // Event: Wenn wir in die Section reinscrollen (von oben)
         onEnter: () => {
            gsap.to(material.uniforms.uProgress, {
               value: section.value,
               duration: 1.5, // Dauer des Morphs (1.5 Sekunden)
               ease: "power2.inOut", // Weicher Start/Stop
               overwrite: true, // Wichtig: Bricht alte Animationen ab
            });
         },

         // Event: Wenn wir ZURÜCK in die Section scrollen (von unten)
         onEnterBack: () => {
            gsap.to(material.uniforms.uProgress, {
               value: section.value,
               duration: 1.5,
               ease: "power2.inOut",
               overwrite: true,
            });
         },
      });
   });

   const tlHero = gsap.timeline({
      scrollTrigger: {
         trigger: "#hero",
         start: "top top",
         end: "bottom top", // Bis der Hero ganz weg ist
         scrub: true, // Animation ist an Scrollbalken gekoppelt
      },
   });

   // 1. Nach rechts schieben (auf 3.0)
   // Die "0" am Ende bedeutet: Startet bei Sekunde 0 der Timeline
   tlHero.to(material.uniforms.uBoxShiftX, { value: 4.0, ease: "none" }, 0);

   // 2. Größer machen (von 1.0 auf 2.5)
   // Auch hier die "0", damit es GLEICHZEITIG passiert
   tlHero.to(material.uniforms.uBoxScale, { value: 4.5, ease: "none" }, 0);

   gsap.to(material.uniforms.uPlaneScaleX, {
      //value: 2.5, // Zieht die Plane auf 250% Breite
      ease: "none",
      scrollTrigger: {
         trigger: "#services", // Wenn Services sichtbar wird
         start: "top bottom", // Sobald der obere Rand unten ins Bild kommt
         end: "bottom top", // Bis er oben wieder raus ist
         //scrub: true, // An Scrollen koppeln
      },
   });

   // *** gsap end ***
</script>
