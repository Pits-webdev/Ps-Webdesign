<canvas id="three-canvas" class="w-full h-full block bg-transparent"></canvas>

<script>
   import { gsap } from "gsap";
   import { ScrollTrigger } from "gsap/ScrollTrigger";
   import * as THREE from "three";
   import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
   import { debug } from "../../lib/debug";
   import { fragmentShader } from "../../shaders/fragment-strips";
   import { vertexShader } from "../../shaders/vertex-strips";

   import { getCssColor } from "../../utils/getCssColor";

   gsap.registerPlugin(ScrollTrigger);

   const threeCanvas = document.getElementById(
      "three-canvas",
   ) as HTMLCanvasElement;

   // browser sizes
   const sizes = {
      width: window.innerWidth,
      height: window.innerHeight,
   };

   //scene
   const scene = new THREE.Scene();

   //camera
   const camera = new THREE.PerspectiveCamera(
      75,
      sizes.width / sizes.height,
      0.1,
      1000,
   );

   camera.position.z = 1;

   //renderer
   const renderer = new THREE.WebGLRenderer({
      //antialias: true, // Antialias an für schönere Partikel
      canvas: threeCanvas,
      alpha: true,
   });

   renderer.setSize(sizes.width, sizes.height);
   renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
   renderer.setAnimationLoop(animate);

   // 2. CONTROLS INITIALISIEREN
   const controls = new OrbitControls(camera, threeCanvas);
   controls.enableDamping = true; // Weiches Bremsen der Kamera
   controls.dampingFactor = 0.05;

   /* Geometries */
   const geometry = new THREE.CircleGeometry(1.75, 32, 0, 6.283);

   // Uniforms
   const uniforms = {
      uTime: { value: 0.0 },
      uResolution: {
         value: new THREE.Vector2(window.innerWidth, window.innerHeight),
      },

      // Farben
      /* uColorBottom: { value: new THREE.Color(getCssColor("--bottomColor")) },
      uColorTop: { value: new THREE.Color(getCssColor("--topColor")) }, */

      // --- NEU: PARAMETER FÜR GUI ---
   };

   //material
   const material = new THREE.ShaderMaterial({
      vertexShader: vertexShader,
      fragmentShader: fragmentShader,
      uniforms: uniforms,
      side: THREE.DoubleSide,
      transparent: true,
      //color: "#FB8C00",
      //transparent: true,
      //depthWrite: false, // Wichtig für Partikel, damit sie sich nicht gegenseitig verdecken
      //blending: THREE.AdditiveBlending, // Lässt sie leuchten
   });

   const mesh = new THREE.Mesh(geometry, material);

   scene.add(mesh);

   /* ****** lil Gui ***** */
   //debug(material);

   const clock = new THREE.Clock();

   //animate
   function animate() {
      material.uniforms.uTime.value = clock.getElapsedTime();
      const time = clock.getElapsedTime();

      //mesh.rotation.x += 0.01;
      //mesh.rotation.y += 0.01;

      // NEU: Loop von 0 bis 3
      // time * 0.5 bestimmt die Geschwindigkeit.
      // % 3.0 sorgt dafür, dass es bei 3.0 wieder auf 0 springt.
      //const progress = (time * 0.5) % 3.0;

      //material.uniforms.uTime.value = time;
      //material.uniforms.uProgress.value = progress;

      // 3. CONTROLS UPDATE (Wichtig für Damping!)
      controls.update();

      renderer.render(scene, camera);
   }

   //resize
   window.addEventListener("resize", () => {
      sizes.width = window.innerWidth;
      sizes.height = window.innerHeight;

      camera.aspect = sizes.width / sizes.height;
      camera.updateProjectionMatrix();

      renderer.setSize(sizes.width, sizes.height);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
   });

   //Three js end

   //  *--- gsap ---*

   // *** gsap end ***
</script>
